{% extends "uke_fingerpicking/base.html" %}
{% load lucide %}

{% block content %}
<div class="container" x-data="tabPlayer()">
    <div class="level">
        <div class="level-left">
            <h1 class="title">{{ tab_sheet.title }}</h1>
            <h2 class="subtitle">{{ tab_sheet.artist }}</h2>
        </div>
        <div class="level-right">
            <div class="field has-addons">
                <div class="control">
                    <input type="number" x-model="bpm" class="input" min="40" max="300">
                </div>
                <div class="control">
                    <a class="button is-static">BPM</a>
                </div>
                <div class="control">
                    <button @click="togglePlay" class="button" :class="{'is-primary': !isPlaying, 'is-danger': isPlaying}">
                        <span class="icon">
                            <template x-if="!isPlaying">
                                {% lucide "play" size=20 %}
                            </template>
                            <template x-if="isPlaying">
                                {% lucide "pause" size=20 %}
                            </template>
                        </span>
                        <span x-text="isPlaying ? 'Pause' : 'Play'"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="tab-display-container">
        <div class="tab-display-wrapper">
            <!-- Fixed legend and playhead -->
            <div class="tab-legend">
                <template x-for="(label, index) in stringLabels" :key="index">
                    <div class="string-label" x-text="label"></div>
                </template>
            </div>
            <div class="playhead"></div>

            <!-- Scrolling content -->
            <div class="tab-content" :style="`transform: translateX(${scrollPosition}px)`">
                <template x-for="(string, sIndex) in stringOrder" :key="sIndex">
                    <div class="tab-line">
                        <template x-for="(beat, bIndex) in beats" :key="bIndex">
                            <div class="tab-cell"
                                 :class="{
                                     'is-empty': !beat[string] || beat[string] === '-',
                                     'is-active': isPlaying && bIndex === currentBeat
                                 }"
                                 x-text="beat[string] || '-'">
                            </div>
                        </template>
                    </div>
                </template>
            </div>
        </div>
    </div>

    <!-- Subtle note display -->
    <div class="current-note-display" x-show="currentNote">
        <span class="current-note" x-text="currentNote"></span>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Note map for each string (frets 0-12)
const NOTE_MAP = {
    'g': ['G', 'G#/Ab', 'A', 'A#/Bb', 'B', 'C', 'C#/Db', 'D', 'D#/Eb', 'E', 'F', 'F#/Gb', 'G'],
    'c': ['C', 'C#/Db', 'D', 'D#/Eb', 'E', 'F', 'F#/Gb', 'G', 'G#/Ab', 'A', 'A#/Bb', 'B', 'C'],
    'e': ['E', 'F', 'F#/Gb', 'G', 'G#/Ab', 'A', 'A#/Bb', 'B', 'C', 'C#/Db', 'D', 'D#/Eb', 'E'],
    'a': ['A', 'A#/Bb', 'B', 'C', 'C#/Db', 'D', 'D#/Eb', 'E', 'F', 'F#/Gb', 'G', 'G#/Ab', 'A'],
};

// String label map for display
const STRING_LABELS = { 'g': 'G', 'c': 'C', 'e': 'E', 'a': 'A' };

document.addEventListener('alpine:init', () => {
    Alpine.data('tabPlayer', () => ({
        stringOrder: ['a', 'e', 'c', 'g'],
        stringLabels: ['A', 'E', 'C', 'G'],
        beats: [], // Will be initialized in init
        isPlaying: false,
        bpm: 120,
        currentBeat: 0,
        scrollPosition: 0,
        animationFrame: null,
        startTime: null,
        beatDuration: 500, // Initial value, will be updated
        cellWidth: 56, // 3.5rem in pixels (3rem width + 0.5rem gap),
        totalWidth: 0, // Will be calculated in init
        currentNote: '',
        currentString: '',
        currentFret: '',
        currentStringLabel: '',

        init() {
            // Add 4 empty beats at the beginning
            const originalBeats = JSON.parse('{{ beats_json|escapejs }}');
            const emptyBeat = { a: '-', e: '-', c: '-', g: '-' };
            this.beats = [
                ...Array(4).fill(emptyBeat),
                ...originalBeats
            ];
            
            this.updateBeatDuration();
            this.$watch('bpm', () => this.updateBeatDuration());
            // Calculate total width of all beats
            this.totalWidth = this.beats.length * this.cellWidth;
            // Set initial note
            this.updateCurrentNote();
        },

        updateBeatDuration() {
            this.beatDuration = 60000 / this.bpm;
        },

        togglePlay() {
            this.isPlaying = !this.isPlaying;
            if (this.isPlaying) {
                this.startTime = null;
                this.animate();
            } else {
                cancelAnimationFrame(this.animationFrame);
            }
        },

        animate(timestamp) {
            if (!this.startTime) this.startTime = timestamp;
            const elapsed = timestamp - this.startTime;
            
            // Calculate current beat and position
            const totalDuration = this.beats.length * this.beatDuration;
            const positionInSong = elapsed % totalDuration;
            const beatPosition = positionInSong / this.beatDuration;
            
            // Update current beat (for highlighting)
            this.currentBeat = Math.floor(beatPosition) % this.beats.length;
            this.updateCurrentNote();
            
            // Calculate scroll position using modulo to create seamless loop
            const beatProgress = beatPosition - Math.floor(beatPosition);
            const rawPosition = (this.currentBeat + beatProgress) * this.cellWidth;
            // Use modulo to create seamless loop
            this.scrollPosition = -(rawPosition % this.totalWidth);
            
            if (this.isPlaying) {
                this.animationFrame = requestAnimationFrame((t) => this.animate(t));
            }
        },

        updateCurrentNote() {
            // Find which string is played (not '-') in the current beat
            const beat = this.beats[this.currentBeat] || {};
            let found = false;
            for (const string of this.stringOrder) {
                const val = beat[string];
                if (val && val !== '-') {
                    const fret = parseInt(val, 10);
                    if (!isNaN(fret) && fret >= 0 && fret < 13) {
                        this.currentNote = NOTE_MAP[string][fret];
                        this.currentString = string;
                        this.currentFret = fret;
                        this.currentStringLabel = STRING_LABELS[string];
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                this.currentNote = '';
                this.currentString = '';
                this.currentFret = '';
                this.currentStringLabel = '';
            }
        }
    }));
});
</script>

<style>
.tab-display-container {
    position: relative;
    overflow: hidden;
    margin: 2rem 0;
    padding: 1rem;
    background: var(--background);
    border-radius: 4px;
}

.tab-display-wrapper {
    position: relative;
    display: flex;
    overflow: hidden;
}

.tab-legend {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 3rem;
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    padding-right: 0.5rem;
    border-right: 1px solid var(--border);
    z-index: 2;
}

.string-label {
    text-align: right;
    padding: 0.5rem;
    font-weight: bold;
    color: var(--text);
}

.playhead {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 3.5rem;
    width: 2px;
    background-color: var(--danger);
    z-index: 2;
    pointer-events: none;
}

.tab-content {
    margin-left: 4rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    will-change: transform;
    transition: transform 0.05s linear;
}

.tab-line {
    display: flex;
    gap: 0.5rem;
}

.tab-cell {
    flex: 0 0 3rem;
    height: 2.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--cell-background);
    border-radius: 4px;
    transition: background-color 0.1s linear;
}

.tab-cell.is-empty {
    visibility: hidden;
}

.tab-cell.is-active {
    background: var(--primary);
    color: var(--primary-invert);
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    :root {
        --background: #1a1a1a;
        --border: #333;
        --cell-background: #2a2a2a;
        --text: #fff;
        --primary: #3273dc;
        --primary-invert: #fff;
        --danger: #ff3860;
    }
}

@media (prefers-color-scheme: light) {
    :root {
        --background: #f5f5f5;
        --border: #dbdbdb;
        --cell-background: #fff;
        --text: #363636;
        --primary: #3273dc;
        --primary-invert: #fff;
        --danger: #ff3860;
    }
}

.current-note-display {
    text-align: center;
    margin-top: 1rem;
    opacity: 0.7;
}

.current-note {
    font-size: 1.2rem;
    font-weight: 500;
    color: var(--text);
}
</style>
{% endblock %} 