{% extends "uke_fingerpicking/base.html" %}
{% load lucide %}

{% block content %}
<div class="container" x-data="app()">
    <div class="level">
        <div class="level-left">
            <h1 class="title">{{ tab_sheet.title }}</h1>
            <h2 class="subtitle">{{ tab_sheet.artist }}</h2>
        </div>
        <div class="level-right">
            <div class="field has-addons">
                <div class="control">
                    <input type="number" x-model="tabPlayer.bpm" class="input" min="40" max="300">
                </div>
                <div class="control">
                    <a class="button is-static">BPM</a>
                </div>
                <div class="control">
                    <button @click="togglePlay" class="button" :class="{'is-primary': !tabPlayer.isPlaying, 'is-danger': tabPlayer.isPlaying}">
                        <span class="icon">
                            <template x-if="!tabPlayer.isPlaying">
                                {% lucide "play" size=20 %}
                            </template>
                            <template x-if="tabPlayer.isPlaying">
                                {% lucide "pause" size=20 %}
                            </template>
                        </span>
                        <span x-text="tabPlayer.isPlaying ? 'Pause' : 'Play'"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="tab-display-container">
        <div class="tab-display-wrapper">
            <!-- Fixed legend and playhead -->
            <div class="tab-legend">
                <template x-for="(label, index) in tabPlayer.stringLabels" :key="index">
                    <div class="string-label" x-text="label"></div>
                </template>
            </div>
            <div class="playhead"></div>

            <!-- Scrolling content -->
            <div class="tab-content" :style="`transform: translateX(${tabPlayer.scrollPosition}px)`">
                <template x-for="(string, sIndex) in tabPlayer.stringOrder" :key="sIndex">
                    <div class="tab-line">
                        <template x-for="(beat, bIndex) in tabPlayer.beats" :key="bIndex">
                            <div class="tab-cell"
                                 :class="{
                                     'is-empty': !beat[string] || beat[string] === '-',
                                     'is-active': tabPlayer.isPlaying && bIndex === tabPlayer.currentBeat
                                 }"
                                 x-text="beat[string] || '-'">
                            </div>
                        </template>
                    </div>
                </template>
            </div>
        </div>
    </div>

    <!-- Subtle note display -->
    <div class="current-note-display" x-show="tabPlayer.currentNote">
        <span class="current-note" x-text="tabPlayer.currentNote"></span>
    </div>

    <!-- Audio detection display -->
    <div class="audio-detection-display">
        <div class="current-note-display">
            <span class="current-note" x-text="audioDetection.detectedNote" x-show="audioDetection.detectedNote"></span>
            <button @click="toggleListening" class="button is-small ml-2" :class="{'is-primary': !audioDetection.isListening, 'is-danger': audioDetection.isListening}">
                <span class="icon">
                    {% lucide "mic" size=16 %}
                </span>
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Audio Detection
class AudioDetector {
    constructor() {
        this.audioContext = null;
        this.analyser = null;
        this.microphone = null;
        this.isListening = false;
        this.noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    }

    async startListening() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048;
            
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            this.microphone = this.audioContext.createMediaStreamSource(stream);
            this.microphone.connect(this.analyser);
            
            this.isListening = true;
            this.detectPitch();
        } catch (error) {
            console.error('Error accessing microphone:', error);
        }
    }

    stopListening() {
        if (this.microphone) {
            this.microphone.disconnect();
            this.microphone = null;
        }
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
        }
        this.isListening = false;
    }

    detectPitch() {
        if (!this.isListening) return;

        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Float32Array(bufferLength);
        this.analyser.getFloatTimeDomainData(dataArray);

        const frequency = this.yinAlgorithm(dataArray);
        if (frequency) {
            const note = this.frequencyToNote(frequency);
            if (note) {
                const event = new CustomEvent('noteDetected', { detail: { note } });
                document.dispatchEvent(event);
            }
        }

        requestAnimationFrame(() => this.detectPitch());
    }

    yinAlgorithm(data) {
        const sampleRate = this.audioContext.sampleRate;
        const tauMin = Math.floor(sampleRate / 1000); // 1ms
        const tauMax = Math.floor(sampleRate / 50);   // 20ms
        
        let bestTau = 0;
        let bestValue = 1;
        
        for (let tau = tauMin; tau < tauMax; tau++) {
            let sum = 0;
            for (let j = 0; j < data.length - tau; j++) {
                const diff = data[j] - data[j + tau];
                sum += diff * diff;
            }
            
            const value = sum / (data.length - tau);
            if (value < bestValue) {
                bestValue = value;
                bestTau = tau;
            }
        }
        
        if (bestValue < 0.1) { // Threshold for valid pitch
            return sampleRate / bestTau;
        }
        return null;
    }

    frequencyToNote(frequency) {
        if (frequency <= 0) return null;
        
        const noteNum = Math.round(12 * Math.log2(frequency / 440) + 69);
        const noteName = this.noteNames[noteNum % 12];
        const octave = Math.floor(noteNum / 12) - 1;
        
        return `${noteName}${octave}`;
    }
}

// Note map for each string (frets 0-12)
const NOTE_MAP = {
    'g': ['G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G'],
    'c': ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C'],
    'e': ['E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E'],
    'a': ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A'],
};

// String label map for display
const STRING_LABELS = { 'g': 'G', 'c': 'C', 'e': 'E', 'a': 'A' };

document.addEventListener('alpine:init', () => {
    Alpine.data('app', () => ({
        // Tab Player State
        tabPlayer: {
            stringOrder: ['a', 'e', 'c', 'g'],
            stringLabels: ['A', 'E', 'C', 'G'],
            beats: [],
            isPlaying: false,
            bpm: 120,
            currentBeat: 0,
            scrollPosition: 0,
            animationFrame: null,
            startTime: null,
            beatDuration: 500,
            cellWidth: 56,
            totalWidth: 0,
            currentNote: '',
            currentString: '',
            currentFret: '',
            currentStringLabel: ''
        },

        // Audio Detection State
        audioDetection: {
            isListening: false,
            detectedNote: ''
        },

        // Audio Detector Instance
        audioDetector: null,

        init() {
            this.initTabPlayer();
            this.initAudioDetection();
        },

        initTabPlayer() {
            const originalBeats = JSON.parse('{{ beats_json|escapejs }}');
            const emptyBeat = { a: '-', e: '-', c: '-', g: '-' };
            this.tabPlayer.beats = [
                ...Array(4).fill(emptyBeat),
                ...originalBeats
            ];
            
            this.updateBeatDuration();
            this.$watch('tabPlayer.bpm', () => this.updateBeatDuration());
            this.tabPlayer.totalWidth = this.tabPlayer.beats.length * this.tabPlayer.cellWidth;
            this.updateCurrentNote();
        },

        initAudioDetection() {
            this.audioDetector = new AudioDetector();
            document.addEventListener('noteDetected', (event) => {
                this.audioDetection.detectedNote = event.detail.note;
            });
        },

        updateBeatDuration() {
            this.tabPlayer.beatDuration = 60000 / this.tabPlayer.bpm;
        },

        togglePlay() {
            this.tabPlayer.isPlaying = !this.tabPlayer.isPlaying;
            if (this.tabPlayer.isPlaying) {
                this.tabPlayer.startTime = null;
                this.animate();
            } else {
                cancelAnimationFrame(this.tabPlayer.animationFrame);
            }
        },

        animate(timestamp) {
            if (!this.tabPlayer.startTime) this.tabPlayer.startTime = timestamp;
            const elapsed = timestamp - this.tabPlayer.startTime;
            
            const totalDuration = this.tabPlayer.beats.length * this.tabPlayer.beatDuration;
            const positionInSong = elapsed % totalDuration;
            const beatPosition = positionInSong / this.tabPlayer.beatDuration;
            
            this.tabPlayer.currentBeat = Math.floor(beatPosition) % this.tabPlayer.beats.length;
            this.updateCurrentNote();
            
            const beatProgress = beatPosition - Math.floor(beatPosition);
            const rawPosition = (this.tabPlayer.currentBeat + beatProgress) * this.tabPlayer.cellWidth;
            this.tabPlayer.scrollPosition = -(rawPosition % this.tabPlayer.totalWidth);
            
            if (this.tabPlayer.isPlaying) {
                this.tabPlayer.animationFrame = requestAnimationFrame((t) => this.animate(t));
            }
        },

        updateCurrentNote() {
            const beat = this.tabPlayer.beats[this.tabPlayer.currentBeat] || {};
            let found = false;
            for (const string of this.tabPlayer.stringOrder) {
                const val = beat[string];
                if (val && val !== '-') {
                    const fret = parseInt(val, 10);
                    if (!isNaN(fret) && fret >= 0 && fret < 13) {
                        this.tabPlayer.currentNote = NOTE_MAP[string][fret];
                        this.tabPlayer.currentString = string;
                        this.tabPlayer.currentFret = fret;
                        this.tabPlayer.currentStringLabel = STRING_LABELS[string];
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                this.tabPlayer.currentNote = '';
                this.tabPlayer.currentString = '';
                this.tabPlayer.currentFret = '';
                this.tabPlayer.currentStringLabel = '';
            }
        },

        toggleListening() {
            if (this.audioDetection.isListening) {
                this.audioDetector.stopListening();
            } else {
                this.audioDetector.startListening();
            }
            this.audioDetection.isListening = !this.audioDetection.isListening;
        }
    }));
});
</script>

<style>
.tab-display-container {
    position: relative;
    overflow: hidden;
    margin: 2rem 0;
    padding: 1rem;
    background: var(--background);
    border-radius: 4px;
}

.tab-display-wrapper {
    position: relative;
    display: flex;
    overflow: hidden;
}

.tab-legend {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 3rem;
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    padding-right: 0.5rem;
    border-right: 1px solid var(--border);
    z-index: 2;
}

.string-label {
    text-align: right;
    padding: 0.5rem;
    font-weight: bold;
    color: var(--text);
}

.playhead {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 3.5rem;
    width: 2px;
    background-color: var(--danger);
    z-index: 2;
    pointer-events: none;
}

.tab-content {
    margin-left: 4rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    will-change: transform;
    transition: transform 0.05s linear;
}

.tab-line {
    display: flex;
    gap: 0.5rem;
}

.tab-cell {
    flex: 0 0 3rem;
    height: 2.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--cell-background);
    border-radius: 4px;
    transition: background-color 0.1s linear;
}

.tab-cell.is-empty {
    visibility: hidden;
}

.tab-cell.is-active {
    background: var(--primary);
    color: var(--primary-invert);
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    :root {
        --background: #1a1a1a;
        --border: #333;
        --cell-background: #2a2a2a;
        --text: #fff;
        --primary: #3273dc;
        --primary-invert: #fff;
        --danger: #ff3860;
    }
}

@media (prefers-color-scheme: light) {
    :root {
        --background: #f5f5f5;
        --border: #dbdbdb;
        --cell-background: #fff;
        --text: #363636;
        --primary: #3273dc;
        --primary-invert: #fff;
        --danger: #ff3860;
    }
}

.audio-detection-display {
    margin-top: 1rem;
    text-align: center;
}

.current-note-display {
    text-align: center;
    margin-top: 1rem;
    opacity: 0.7;
}

.current-note {
    font-size: 1.2rem;
    font-weight: 500;
    color: var(--text);
}
</style>
{% endblock %} 